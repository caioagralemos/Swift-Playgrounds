@GuideBook(title: "Keep Going with Apps", icon: DocumentThumbnail.png, background: titleBackground.png, firstFile: ConditionalViews.swift) {
    @Intro(title: "Keep Going with Apps", guideImage: "Introduction.png") { 
        In Get Started with Apps, you learned how to use SwiftUI [views](glossary://view) to create a simple user interface. In SwiftUI, [views](glossary://view) are [UI](glossary://user%20interface) building blocks that you can place inside one another to piece together more complex [composed views](glossary://composed%view).
        
       Here, you'll learn about [state](glossary://state) and [data flow](glossary://data%20flow) in SwiftUI. Data flow is the movement of values throughout your app, and how SwiftUI updates your UI to reflect any changes to those values. Importantly, you'll learn how to [separate your app data](glossary://data%20separation) from the views that display it, and why this separation is beneficial.
        
        By the end of this tutorial, you will create a fully functioning SwiftUI app that people can add, delete, and modify emoji creatures in. Get started and you'll have an app created in no time.
    }
    @Guide {
        @Step(title: "Modifying State") {
            @ContentAndMedia {
                ![](ModifyingState.png)

                In coding, the term [state](glossary://state) refers to the current value of a variable. A [state change](glossary://state%20change) is when the value of one or more variables change in your app.
                
                One big advantage of SwiftUI is that it can update your views' appearances automatically whenever your app's [state changes](glossary://state%20change). 
                
                When you connect your UI to some app data, such as a [Boolean](glossary://Boolean) or array of [String](glossary://String) values, SwiftUI can [observe](glossary://observe) that data, updating the views that use the data any time it changes. This means you never have to write any code that tells your UI specifically how or when to update.
            }
            @Task(type: walkthrough, title: "Use a state property to update a view", id: "conditionalViews", file: ConditionalViews.swift) {
                @Page(id: "conditionalView.preview", title: "") {
                    In this example, SwiftUI updates a view's appearance when a [state change](glossary://state%20change) occurs. 
                    
                    Tap the button in the preview. This switches the value of the `isOn` [property](glossary://property) between `true` and `false` [states](glossary://state), causing the `Circle` view to appear, disappear, and reappear again. 
                }
                @Page(id: "conditionalView.stateVar", title: "") {
                    When you want to modify the appearance of a view, you'll first need some data to track its [state](glossary://state). You store this data as a [property](glossary://property) of the view. 
                    
                    Think of the data in your view as the [source of truth](glossary://source%20of%20truth) that determines how your [UI](glossary://user%20interface) should appear. Instead of modifying the view directly, you modify the data and SwiftUI updates the view for you. Here, your data is a [Boolean](glossary://Boolean) value that determines whether the view is showing (`true`) or hiding (`false`). 
                }
                @Page(id: "conditionalView.stateVar", title: "") {
                    Important: Always create your data outside of the view [body](glossary://body). Think of the `body` as a ‚ùå no-data-creation zone that's only used to declare what your views look like. This is a core principle of creating apps, known as [data separation](glossary://data%20separation).
                }
                @Page(id: "conditionalView.statePropertyWrapper", title: "") {
                    To allow SwiftUI to update your views automatically, you need to tell it which view [properties](glossary://property) it should manage and track for you.
                    
                    To do this, add a special syntax, called a [property wrapper](glossary://property%20wrapper), before your property definition. Adding the `@State` property wrapper before `isOn` turns it into a [state property](glossary://state%20property). SwiftUI manages the value and updates the affected parts of the view whenever its [state](glossary://state) changes.
                }
                @Page(id: "conditionalView.button", title: "") {
					So how can you change the [state](glossary://state) of `isOn`? One common way is through [user interaction](glossary://user%20interaction), such as when a person taps a `Button`. 
										
					To create a `Button`, pass in a text [label](glossary://label), like "Press Me", and an action [closure](glossary://closure), a block of code that runs when you tap the button.
                }
                @Page(id: "conditionalView.buttonAction", title: "") {
                     When a person taps the button, the action [closure](glossary://closure) changes the value of `isOn` using the `toggle()` method.
                    
                    `toggle()` changes the value to `true` if it's `false`, and to `false` if it's `true`, sort of like turning a light switch on or off.
                }
                @Page(id: "conditionalView.ifStatement", title: "") {
                    This `if` statement uses `isOn` as a condition to show the enclosed view when `true`, and to hide it when `false`.
					
					This is how the `isOn` data connects to the view. Its current [state](glossary://state) determines how the UI appears.
                }
                @Page(id: "conditionalView.circleView", title: "") {
                   When you tap the button in the preview, the circle view in the `if` statement displays or hides. 
                   
                   Try changing the circle's color and tapping the button again. Try changing the initial value of `isOn` to `true`. What changes do you notice in each case?
                }
            }
            @Task(type: addCode, title: "Add an `else` statement that shows a different color circle", id: "addElse", file: ConditionalViews.swift) {
                @Page(id: "elseIntroduction", title: "") {
                    Take a moment to reflect on how tapping the button updates the view. When you tap the `Button`, you change the [state](glossary://state) of `isOn`. SwiftUI [observes](glossary://observe) this change, and updates the view using the new value. In your view [body](glossary://body), you use an `if` statement to display the view if `isOn` is `true` and to hide it if `false`.
                }
                @Page(id: "elseStatement", title: "") {
                     Instead of showing no views when `isOn` is `false`, you can display a custom view. 
                     
                     After the `if` statement, add an `else` statement that shows a `Circle` of a different color.
                }
                @Page(id: "elseClue", title: "", isAddable: false) {
                     Add an `else` statement using the following syntax, then add a `Circle` view and specify its color.
                     
                     ```
                     else { 
                     
                     }
                     ```
                }
                @Page(id: "elseSolution", title: "", isHidden: true, isAddable: true) {
                     ```
                     else { 
                        Circle()
                            .frame(maxHeight: 200)
                            .foregroundColor(.black)
                        //#-learning-code-snippet(addOffText)
                     }
                     ```
                }
            }
            @Task(type: addCode, title: "Add detail to the on and off views", id: "customizeConditionalViews", file: ConditionalViews.swift) {
                @Page(id: "customizeIntro", title: "") {
                     Now that you have two views, customize them to make it clear which view is "on" and which is "off".
					 
					 Try using a `Text` view to label each view. Label the first one "On".
										  
					 ```
					 Text("On")
					 ```
                }
                @Page(id: "addOffText", title: "") {
                     Label the second view as "Off".
                     
                     ```
                     Text("Off")
                     ```
                }
                @Page(id: "customize", title: "") {
					 And finally, make each view a different shape, such as a `Rectangle` or a `Capsule`.
                }
                @Page(id: "customizeExample", title: "", isHidden: true, isAddable: false) {
                  ```
				  if isOn {
                        Circle()
                            .frame(maxHeight: 200)
                            .foregroundColor(.mint)
					  
                        Text("On")
				  } else {
                        Rectangle()
                            .frame(maxHeight: 200)
                            .foregroundColor(.gray)
					  
                        Text("Off")
				  }
                  ```
                }
            }
            @Task(type: experiment, title: "Add a new conditional view", id: "addNewConditionalView", file: ConditionalViews.swift) {
                @Page(id: "addNewConditionalView", title: "") {
                      Now, try adding a completely new conditional view by yourself:
					  
					  1. Add a [state property](glossary://state%20value) outside of the [body](glossary://body) and give it an initial Boolean value. 
					  2. Create an [if statement](glossary://if%20statement) that shows one view if the value of your state property is `true`, and another view if it's `false`.
					  3. Create a new `Button` and toggle your state property whenever you press it.
					  
					Does your conditional view work as you expect? 
                }
                @Page(id: "explainToSelf", title: "") {
                      Before moving on, try using the [rubber ducky method](glossary://rubber%20ducky%20method) to explain how conditional view code works in as much detail as you can. What does a state property do? How does your view know when to update? If you can't remember something, go back and try to figure out where your knowledge is missing. Your rubber ducky will thank you!
                }
            }
            @SuccessMessage(message: "") { 
                Wahoo! 
                
                You now understand how to use a [state property](glossary://state%20value) to update the appearance of a SwiftUI view. This state property is stored outside of the view [body](glossary://body), where you declare the UI of the view.
                
                This is a fundamental principle of coding apps in SwiftUI -- always keep your app data separate from the UI that displays it. Doing this allows you to preserve a single [source of truth](glossary://source%20of%20truth), and keeps your UI code easy to understand and maintain.
            }
        }
        @Step(title: "Using a Conditional Modifier") {
            @ContentAndMedia {
                ![](UsingAConditionalModifier.png)
                
                In the previous example, you created a [state property](glossary://state%20property) `isOn` whose storage is managed by SwiftUI. By changing the [state](glossary://state) of `isOn`, you were able to show one of two different views conditionally. 
				
				But what if you simply want to change the appearance of an existing view, such as the color or size of a `Circle` view? For that, you'll need to write some conditional code that specifies how the view appears when [state changes](glossary://state%20change) occur.
            }
            @Task(type: walkthrough, title: "Change view modifiers conditionally", id: "conditionalCircle", file: ConditionalCircle.swift) {
                @Page(id: "identifyTheDifferent", title: "") {
                    Like the previous view, this view also uses a [state property](glossary://state%20property) and a `Button` to change the appearance of a `Circle`. However, something is different in this code. Take a second to try to figure out what has changed, moving on when you think you've found it.
                }
                @Page(id: "conditionalCircle.circleView", title: "") {
					Did you figure out how it works? 
					
					Instead of creating a different view when `isOn` is `true` or `false`, you can modify the appearance of a single view using [view modifiers](glossary://modifier) that contain conditional code.
                }
                @Page(id: "conditionalCircle.foregroundColor", title: "") {
                    Notice that the `.foregroundColor(_:)` modifier contains special syntax. This is called a [ternary conditional operator](glossary://ternary%20conditional%20operator), a concise way of creating an `if-else` statement in a single line of code.
                }
                @Page(id: "conditionalCircle.ternary", title: "", isAddable: false) {
                    You can read this code as: if `isOn` is `true`, pass in the value `.yellow`; otherwise, pass in `.black`.
                    
                    ```
                    isOn ? .yellow : black
                    ```
					
					More generically, this looks like: 
										
					``` 
					condition ? trueValue : falseValue
					```
                }
                @Page(id: "conditionalCircle.ternary", title: "") {
                    Try changing the color of the circle to `.purple` when `isOn` is `true`, and to a lighter shade of green, like `.mint`, when `false`.
                }
            }
            @Task(type: addCode, title: "Add a `shadow(color:radius:)` modifier that shows a different color shadow in each state", id: "addShadowModifier", file: ConditionalCircle.swift) {
                @Page(id: "intro", title: "") {
                     Just like the `ConditionalViews` example, SwiftUI [observes](glossary://observe) the `isOn` [state property](glossary://state%20property). When the value of `isOn` changes, SwiftUI updates the `Circle` view with the new value for its `.foregroundColor(_:)` modifier.
                     
                     Next, try adding another modifier, `.shadow(color:radius:)` that uses the `isOn` value to change the view's shadow.
                }
                 @Page(id: "shadow", title: "", isAddable: true) {
                     First, add the modifier `.shadow(color:radius:)` to `Circle`.

                    ```
                    .shadow(color: <#T##Color#>, radius: 20)
                    ```
                 }
                 @Page(id: "shadowModifier", title: "") {
                     For the modifier's `color` parameter, use the [ternary conditional operator](glossary://ternary%20conditional%20operator) to change the color of the shadow based on the [state](glossary://state) of `isOn`.
                 }
                 @Page(id: "ternarySyntax", title: "", isAddable: false) {
                     The ternary operator syntax looks like this: 
                     
                     ```
                     isOn ? .indigo : .orange
                     ```
                     
                     This code snippet can be read as: if `isOn` is `true`, use the value `.indigo`; otherwise, use the value `.orange`.
                 }
                 @Page(id: "elseCode", title: "", isHidden: true, isAddable: true) {
                     ```
                     .shadow(color: isOn ? .indigo : .orange, radius: 20)
                     ```
                 }
            }
            @Task(type: addCode, title: "Change the scale of the circle when tapping the button", id: "addScaleModifier", file: ConditionalCircle.swift) {
                 @Page(id: "scale", title: "") {
                     Time to try it yourself. See if you can figure out how to use the `.scaleEffect(_:)` modifier with a [ternary conditional operator](glossary://ternary%20conditional%20operator) to change the scale of the circle based on the state of `isOn`. 
                 }
                 @Page(id: "scaleHint", title: "", isAddable: true) {
                     First, add the `.scaleEffect(_:)` modifier to the circle. Then, use the ternary operator to specify one scale if `isOn` is `true`, and to another if `false`. 
                     
                     ```
                     .scaleEffect(<#T##s: CGFloat##CGFloat#>)
                     ```
                 }
                 @Page(id: "elseCode", title: "", isHidden: true, isAddable: true) {
                     ```
                     .scaleEffect(isOn ? 1 : 0.75)
                     ```
                 }
            }
            @Task(type: addCode, title: "Animate your state changes", id: "addAnimationModifier", file: ConditionalCircle.swift) {
                 @Page(id: "animation", title: "") {
                     Just like SwiftUI knows how to update your views automatically, it also knows how to animate changes to your views based upon the values that you change. 
                     
                     To do this, attach a `.animation(_:value:)` modifier to the view you want to animate, and select an `Animation` as well as a value to monitor for changes.
                 }
                 @Page(id: "animationExample", title: "", isAddable: false) {
                     For example, you can use a default animation to animate any changes to the `isOn` value.
                     
                     ```
                     .animation(.default, value: isOn)
                     ```
                     
                     When `isOn` changes, the view modifications controlled by this value will animate. Because you use `isOn` to determine the view's shadow, color, and scale, all of those features will animate to their new state when the value changes.
                     
                 }
                 @Page(id: "animationSolution", title: "", isHidden: true, isAddable: true) {
                     ```
                     .animation(.default, value: isOn)
                     ```
                 }
                 @Page(id: "animationExperiments", title: "", isAddable: false) {
                     Try changing the default animation to something different. `.default` gives you the animation `.easeInOut`, but you can change it to `.spring(response:dampingFraction:blendDuration:)` or `.linear(duration:)` to see how the animation changes.
                 }
            }
            @SuccessMessage(message: "") {
                Excellent work! 
                
                You now know how to use a [state property](glossary://state%20property) to change the appearance of a view, and how to animate those changes using the `.animation(_:value:)` modifier.
                
                Next, you'll learn how to use SwiftUI [built-in views](glossary://built-in%20view) and [bindings](glossary://binding) to create different types of state changes in your UI. 
            }
        }
        @Step(title: "SwiftUI Built-in Views") {
            @ContentAndMedia {
                ![](SwiftUIBuilt-inViews.png)
                
                SwiftUI provides many [built-in views](glossary://built-in%20view), such as sliders, toggles, and pickers, that enable someone to change the state of app data by [interacting](glossary://user%20interaction) with them. 
                
                These built-in views have a special way of sharing data with another view, called a [binding](glossary://binding). 
                
                You can use these built-in views with binding values to change your app's data, and in turn, your app's UI. 
            }
            @Task(type: walkthrough, title: "Use a binding", id: "toggleExperiment", file: Bindings.swift) {
                @Page(id: "toggle.bindingIntro", title: "") {
                    So far, you've used a state property to change your UI [locally](glossary://local%20scope), or within the same view. An example of this is defining a [state property](glossary://state%20property) in `ConditionalCircle`, and using it to change the appearance of a view in the [body](glossary://body) of `ConditionalCircle`. 
                }
                @Page(id: "toggle.bindingIntro2", title: "") {
                    But what if you want to allow a [subview](glossary://subview) to change that data? For instance, if your [local](glossary://local%20scope) view stores your contact information, the subview could provide a custom [interaction](glossary://user%20interaction) for you to change the phone number of the contact. But how can you allow the subview to change the data without creating more than one [source of truth](glossary://source%20of%20truth)?
                }
                @Page(id: "toggle.bindingExpanded", title: "") {
                    The key to communicating data changes between two views is called a [binding](glossary://binding). A binding lets you keep a single source of truth, but allows a [subview](glossary://subview) to modify that value remotely. It's called a binding because the source of truth, such as a [state property](glossary://state%20property), binds (or connects) to a second view, and any time the second view changes the data, the source of truth is updated.
                }
                @Page(id: "", title: "") {
                    Try tapping on the `Toggle` in the preview.
            
                    Notice that both the `Image` and `Toggle` views change their appearance when you tap the toggle. The `Toggle` can change the [source of truth](glossary://source%20of%20truth) remotely, allowing itself and the `Image` view to share the same value even though they're two separate views.
                }
                @Page(id: "toggle.stateVar", title: "") {
                    This is your source of truth -- a [state property](glossary://state%20property) that you store [locally](glossary://local%20scope) in the `Bindings` view. A binding's source of truth must be one whose value is managed by SwiftUI, such as by adding the `@State` [property wrapper](glossary://property%20wrapper) to it.
                }
                @Page(id: "toggle.viewDef", title: "") {
                    This is the built-in `Toggle` view. A `Toggle` accepts a [binding](glossary://binding) Boolean value for its `isOn` parameter. This means that the toggle view knows how to change `Boolean` value based on some [user interaction](glossary://user%20interaction), like when a person taps the toggle on or off, and communicates any state changes back to your local [source of truth](glossary://source%20of%20truth), `isOn`.
                }
                @Page(id: "toggle.binding", title: "") {
                    To pass in a binding, use your SwiftUI-managed [state property](glossary://state%20property) with a `$` in front of it. Pass in `$isOn` to indicate that any time `Toggle` changes the value remotely, the [binding](glossary://binding) modifies the source of truth, `isOn`. 
                }
            }
            @Task(type: addCode, title: "Add a new state property, of type `Color`", id: "addAStateVar", file: Bindings.swift) {
                @Page(id: "stateVar", title: "") {
                   Next, try using a built-in `ColorPicker` view along with a [binding](glossary://binding) to change the color of the battery `Image` view.  
				   
				   To do this, first create a [state property](glossary://state%20property) to act as your source of truth for a `Color` value. Give it an initial value of `Color.primary`.
                   
                   Try this on your own, using the following hints if you get stuck.
                }
                @Page(id: "colorVarDefinition", title: "") {
                    Define a [property](glossary://property) with the `@State` [property wrapper](glossary://property%20wrapper) and [assign](glossary://assignment) it an initial value of `Color.primary`.
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: true) {
                    ```
                    @State var color = Color.primary
                    ``` 
                }
            }
            @Task(type: addCode, title: "Create a `ColorPicker` and pass in your binding value", id: "addAColorPicker", file: Bindings.swift) {
                @Page(id: "colorPicker", title: "", isAddable: true) {
                    Below your `Toggle` view, create a `ColorPicker` using the following initializer. Add the arguments yourself, using `Toggle` as an example.
                    
                    ```
                    ColorPicker(<#T##title: StringProtocol##StringProtocol#>, selection: <#T##Binding<CGColor>#>)
                    ```
                }
                @Page(id: "colorPickerArgs", title: "", isAddable: false) {
					1. Pass in a `String` for the title, such as "Select a Color".
					2. Pass in your binding value to `selection`, adding a `$` before the color [state property](glossary://state%20property).
                    
                    If you would like to test the `Bindings` view in your app, temporarily add it to your `ContentView`.
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: true) {
                    ```
                    ColorPicker("Select a Color", selection: $color) 
                    ```
                }
            }
            @Task(type: addCode, title: "Set the color of the `Image` to your color state property", id: "addAColorModifier", file: Bindings.swift) {
                @Page(id: "colorPicker", title: "", isAddable: false) {
                    1. Try selecting a color from the `ColorPicker` in the preview. Notice that the picker color changes, but nothing else in your UI does. This is because your state property isn't connected to any other [local](glossary://local%20scope) views. 
                    
                    2. Now change the color of the image view to update to the color from the picker.
                }
                @Page(id: "padding", title: "") {
                    To change the color of the `Image` view, add a `.foregroundColor(_:)` modifier and pass in your state property for color as an argument.
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: true) {
                    ```
                    .foregroundColor(color)
                    ```
                }
                @Page(id: "tryIt", title: "", isHidden: false) {
                    Now select a color from the color picker. Does your `Image` change color as well?
                }
            }
            @Task(type: experiment, title: "Create a `Text` view that changes its color when you select a new color", id: "addATextView", file: Bindings.swift) {
                @Page(id: "addTextView", title: "") {
                    Add a `Text` view that changes color when you select a new color from the color picker. You can use the `.foregroundColor(_:)` modifier to do this, just as for the image. 
                    
                    Choose a larger font for the `Text` view using the [.font](doc://com.apple.documentation/documentation/swiftui/font) modifier and passing in `.largeTitle`.
                }
                @Page(id: "addPaddingToView", title: "") {
                    Add `.padding()` to your views to create fixed space between one view and all of the views around it. You can also add a `Spacer()`, which is an invisible view that shrinks and expands variably to occupy the available space between views.
                    
                    [Padding](doc://com.apple.documentation/documentation/swiftui/view/padding(_:_:)) and [spacers](doc://com.apple.documentation/documentation/swiftui/spacer) allow you to create adaptive view layouts that make your view look good across a variety of screen sizes. Check out [Laying Out a Simple View](doc://com.apple.documentation/documentation/swiftui/laying-out-a-simple-view) to learn more.
                }
            }
            @SuccessMessage(message: "") { 
                Bravo! 
                
                You now know how to use a built-in SwiftUI view, such as a `ColorPicker`, along with a [binding](glossary://binding) to create custom [interactions](glossary://user%20interaction) for changing your app state. 
                
                Together with your knowledge on [state properties](glossary://state%20property), this allows you to create rich user interactions that change the appearance of your app's UI.
            }
        }
        @Step(title: "Practice with SwiftUI Built-in Views") {
            @ContentAndMedia {  
                ![](PracticeWithSwiftUIBuilt-inViews.png)
                
                Now that you know the basics of state properties, bindings, and built-in SwiftUI views, its time to build some examples by yourself. 
                
                First, you'll use a built-in `Slider` view to change a [state property](glossary://state%20property) that controls the width of a `Rectangle`. 
                
                Then you'll try creating a story editor using built-in `TextField` views to change the value of some `String` state property, resulting in an interesting narrative.
            }
            @Task(type: addCode, title: "Create a slider", id: "buildASlider", file: SlidingRectangle.swift) {
                @Page(id: "sliderTask", title: "", isAddable: false) {
                    Create a view that uses a built-in `Slider` to change the width of a `Rectangle` view. To accomplish this, you'll need to define a new [state property](glossary://state%20property), and pass it into the `Slider` as a [binding](glossary://binding).
                    
                    You can change a view's width with the `.frame(width:)` modifier. Note: This modifier accepts a [Double](doc://com.apple.documentation/documentation/swift/double) value (a special [type](glossary://type) of number value), so define your state property as a `Double`.
                    
                    Take a moment to try this out on your own, using the following hints if you get stuck.
                }
                @Page(id: "width", title: "", isHidden: true, isAddable: true) {
                    Define a state property of type `Double` above the `body` of the view. This is your local [source of truth](glossary://source%20of%20truth).
                    
                    ```
                    @State var width : Double = 0
                    ```
                }
                @Page(id: "slider", title: "", isHidden: true, isAddable: true) {
                    Create your `Slider`, using the initializer `Slider(value:)`. Pass in a [binding](glossary://binding) to your [state property](glossary://state%20property).
                    
                    ```
                    Slider(value: $width)
                    ```
                }
                @Page(id: "rectangle", title: "", isHidden: true, isAddable: true) {
                    Create a `Rectangle` and add the `.frame(width:)` modifier to it. Since the value of a default slider ranges from `0` to `1`, multiply the width by a larger number so you can notice the changes to the value.
                    
                    ```
                    Rectangle()
                        .frame(width: width * 300)
                    ```
                }
            }
            @Task(type: experiment, title: "Create a story", id: "storyEditor", file: StoryEditor.swift) {
                @Page(id: "storyEditor", title: "", isAddable: true) {
                    Here's another experiment for you to try:
                    
                    You can use the SwiftUI [TextField](doc://com.apple.documentation/documentation/swiftui/textfield) to change `String` values based upon the characters a person types into the field. 
                    
                    1. Create a customizable story by defining multiple [state properties](glossary://state%20property) along with corresponding `TextField` views to allow someone to enter data like their name, a hobby, and a favorite food.
                    2. Below the text fields, create a `Text` view that merges all of the values together using [string interpolation](glossary://string%20interpolation) to create a story. It might look something like this: 
                    
                    ```
                    Text("Hello, my name is \(name), my favorite hobby is \(hobby) and I can't stop eating \(favoriteFood)!")
                    ```
                }
                @Page(id: "storyEditor2", title: "") {
                   Bonus: Add a `Button` or `Toggle` view that shows the story when you tap it.
                }
            }
            @SuccessMessage(message: "") { 
                You're getting this! 
                
                You can now handle state changes locally using state properties, and between two views using bindings. 
                
                Next, you'll find out how to create data that you can use across every view of your app. 
            }
        }
        @Step(title: "Navigating in SwiftUI") {
            @ContentAndMedia {
                ![](NavigatingInSwiftUI.png)  
                
                Now that you're getting the hang of how to manage state within a single SwiftUI view, it's time to start thinking bigger. 
                
                In some cases when you build an app, you'll have data that you want to share across two or more views, so even a [binding](glossary://binding) won't be enough to handle that. You shouldn't try to replicate the data in each new view, as this would be very difficult to keep track of, and it could lead to bugs in your app. Instead, you'll learn how to create and maintain a single [data model](glossary://data%20model) that multiple views of your app can use. 
                
                But before you see how to do that, you need to know how to create an app with multiple views. For this, you'll add navigation using a `NavigationSplitView` or a `NavigationStack`.
            }
            @Task(type: addCode, title: "Create a `NavigationStack`", id: "navigationExperiment", file: NavigationExperiment.swift) {
                @Page(id: "navViewExplanation", title: "") {
                    To navigate to different views, you'll need one of two different types of navigation views: 
                    1. A [NavigationStack](doc://com.apple.documentation/documentation/swiftui/navigationstack) organizes your views on top of each other, like a deck of cards.
                    2. A [NavigationSplitView](doc://com.apple.documentation/documentation/swiftui/navigationsplitview) organizes your views in two or three columns, allowing you to select items from the leading column to present a view in the trailing column.
                }
                @Page(id: "navViewExplanation", title: "") {
                    Each of these navigation views act as a [container](glossary://container) for presenting different views based on how someone navigates within your app, they just present the views in slightly different ways.

                    First, you'll create a `NavigationStack` to see how it works.
                }
                @Page(id: "addNavigationStack", title: "", isAddable: true) {
                     First, add a `NavigationStack` with a `List` view inside. A [List](doc://com.apple.documentation/documentation/swiftui/list) displays any number of views in a scrolling vertical column.
                     
                     ```
                     NavigationStack { 
                        List { 
                            Text("NavigationStack Content")
                            //#-learning-code-snippet(addNavLink)
                            //#-learning-code-snippet(addSecondNavLink)

                        }
                     }
                     ```
                }
                @Page(id: "navViewExplanation", title: "", isAddable: true) {
                     Look at your preview. You'll see a single `Text` view in your `List` and not much else. To navigate to another view, you'll add a [NavigationLink](glossary://navigation%20link) inside of your `NavigationStack`.

                     So why did you bother creating a `NavigationStack` if a `NavigationLink` is what takes you to another view? Well, just like you can't ride a bicycle without wheels, you can't navigate to another view unless your links are inside a `NavigationStack` or `NavigationSplitView`.
                }
            }
            @Task(type: addCode, title: "Create a navigation link", id: "addNavLink", file: NavigationExperiment.swift) {
                @Page(id: "navLinkIntro", title: "") {
                    Your `NavigationStack` and `NavigationSplitView` can show different content based on how a person interacts with your app. For your navigation view to display a different view, create a [NavigationLink](glossary://navigation%20link), a button that a person can tap to navigate to a separate view.
                }
                @Page(id: "navLinkExplanation", title: "") {
                    A `NavigationLink` must contain two things: 
                    1. A link to the [destination view](glossary://destination%20view).
                    2. A [label](glossary://label) (how the button should appear). 
                    
                    The destination can be any view you want -- something simple like a `Text` or `Image` view, or even a [composed view](glossary://composed%20view) you've created yourself. 
                }
                @Page(id: "addNavLink", title: "", isAddable: true) {
                    The code below creates a `NavigationLink` with a `Text` view as the [label](glossary://label) and a `Text` view as the [destination](glossary://destination%20view). 
                    
                    Try adding the `NavigationLink` below and tap the link in the preview.
                     
                     ```
                     NavigationLink("Push Me!") { 
                        Text("I'm the destination View")
                            .navigationTitle("Destination")
                     }
                     ```
                }
                @Page(id: "addSecondNavLink", title: "", isAddable: true) {
                    Add one more navigation link, and try navigating to the different views in your `NavigationStack`.
                    
                    Because a `NavigationStack` acts like a deck of cards, it will only ever display the view that's on top. Navigating to a new view pushes it to the top of the stack so it can be seen.
                     
                     ```
                     NavigationLink("No, Push Me!") { 
                        Text("I'm another destination view")
                            .navigationTitle("Destination")
                     }
                     ```
                }
            }
            @Task(type: experiment, title: "Experiment with a `NavigationSplitView`", id: "navigationSplitViewExperiment", file: NavigationSplitViewExperiment.swift) {
                @Page(id: "replaceNavStack", title: "") {
                    Next, you'll create a `NavigationSplitView` to display content as columns.
                    
                    You'll use a navigation links as your leading column, and when tapped, each of these will display some text in the trailing column.
                }
                @Page(id: "addNavSplitView", title: "", isAddable: true) {
                    First, add your `NavigationSplitView`. You'll notice that there are two sections: the first section is the leading column of the split view, and the second is a [placeholder view](glossary://placeholder%20view) that shows some temporary content until you select one of the links.
                    
                    ```
                    NavigationSplitView { 
                        //#-learning-code-snippet(listOfLinks)

                    } detail: { 
                        //#-learning-code-snippet(detailView)
                        
                    }
                    ```
                }
                @Page(id: "listOfLinks", title: "", isAddable: true) {
                    Next, add some links to your `NavigationSplitView`. 
                    
                    You might notice that the view still looks the same as a `NavigationStack` if you have a small preview size. Try expanding the preview to see multiple columns.
                    
                    ```
                    List {
                        NavigationLink("First link") {
                            Text("üòµ‚Äçüí´")
                        }
                        NavigationLink("Second link") {
                            Text("üòµ‚Äç")
                        }
                        //#-learning-code-snippet(addMoreNavLinks)
                    }
                    ```
                }
                @Page(id: "detailView", title: "", isAddable: true) {
                    Finally, add a [placeholder view](glossary://placeholder%20view) to provide some initial content for your second column.
                    
                    You can see this placeholder content by expanding your preview and restarting it before selecting a link.
                    
                    ```
                    Text("Select a link")
                    ```
                }
            }
            @Task(type: experiment, title: "Experiment with NavigationLinks", id: "addMoreNavLinks", file: NavigationSplitViewExperiment.swift) {
                @Page(id: "tryMoreLInks", title: "") {
                    If you want to customize the appearance of your `NavigationLink`, you can use a different [initializer](glossary://initializer) that takes a custom [label](glossary://label).
                }
                @Page(id: "addNavBarTitle", title: "", isAddable: true) {
                    The code below creates a `NavigationLink` with a custom [label](glossary://label), composed of an `HStack` with a `Text` and `Image` view. As with the destination content, the label can be any view you want!
                    ```
                    NavigationLink { 
                        SlidingRectangle()
                           .navigationTitle("Sliding Rectangle")
                    } label: { 
                        HStack { 
                            Text("Tap To Navigate")
                            Spacer()
                            Image(systemName: "arrow.forward.circle")
                                .font(.largeTitle)
                        }
                    }
                    ```
                }
                @Page(id: "runApp", title: "", isAddable: true) {
                    Try adding a new `NavigationLink`, giving it a destination, label, and navigation title. Try navigating to one of the other views in the app, such as the `ConditionalCircle` view.
                }
            }
            @Task(type: walkthrough, title: "Understand how your app displays views", id: "myApp", file: MyApp.swift) {
                @Page(id: "transition", title: "") {
                    Now that you've experimented with adding [navigation links](glossary://navigation%20link) inside of a `NavigationStack` and `NavigationSplitView`, your goal is to make the first view your app displays a `NavigationStack`. After adding navigation links, this allows people to navigate to different views when they use your app.
                }
                @Page(id: "myApp.appProtocol", title: "") {
                    You tell your app which view to display first in your app definition. Here, you can see that your app is named `MyApp` by default, and it follows the guidelines of the `App` [protocol](glossary://protocol), which allows it to run on your device just like any other app. 
                    
                    Try running the current project as an app by pressing the run button (‚ñ∂Ô∏é). You shouldn't see much yet. üôà
                }
                @Page(id: "myApp.body", title: "") {
                    The `body` property of your app defines its content. For now, all you need to know is that you'll need at least one view inside of a `WindowGroup`, which acts as a container for your app's [view hierarchy](glossary://view%20hierarchy), a collection of views that your app presents when it launches.
                }
                @Page(id: "myApp.contentView", title: "") {
                    `ContentView` is your [top-level view](glossary://top-level%20view), the first view your app displays when it launches. It sits on top of your [view hierarchy](glossary://view%20hierarchy), which is a structured collection of [subviews](glossary://subview) that branch off from your top-level view.
                }
                @Page(id: "myApp.contentView", title: "") {
                    Try temporarily changing `ContentView` to some other view, such as a `Text` or `Image` view, then run your app. Notice that your app's top-level view has changed -- this is how you change what content your app shows.
                    
                    When you're ready, change your top-level view back to `ContentView`.
                }
            }
            @Task(type: addCode, title: "Add a `NavigationStack` to your app", id: "addNavView", file: MyApp.swift) {
                @Page(id: "navViewExplanation", title: "") {
                    To display multiple views in your app, you'll turn your [top-level view](glossary://top-level%20view) into a [NavigationStack](doc://com.apple.documentation/documentation/swiftui/navigationstack).
                }
                @Page(id: "addNavView", title: "") {
                     Add a `NavigationStack` inside the `SPCAssessableWindowGroup` of the app `body`:
                     
                     ``` 
                     NavigationStack { 
                     
                     }
                     //#-learning-code-snippet(environmentObjectModifier)
                     ```
                }
                @Page(id: "addContentViewInside", title: "") {
                    Place your `ContentView` inside of the `NavigationStack`. 
                    
                    The first view placed inside the `NavigationStack` displays the initial content. This content can change whenever you use a [navigation link](glossary://navigation%20link) to display a new view. 
                }
                @Page(id: "addContentViewInside", title: "", isHidden: true, isAddable: false) {
                     Your app `body` now looks like this: 
                     
                     ```
                     SPCAssessableWindowGroup(app: self, assessmentCandidates: [CreatureZoo()]) { 
                        NavigationStack { 
                            ContentView()
                        }
                     }
                     ```
                }
            }
            @Task(type: addCode, title: "Add a navigation title", id: "addNavTitle", file: MyApp.swift) {
                @Page(id: "tryRunningApp", title: "") {
                    Run your app. It doesn‚Äôt look too different, does it? This is because the `NavigationStack` acts like a container to show its content by default. 
                    
                    However, a `NavigationStack` provides you with a dedicated space, known as a [navigation bar](glossary://navigation%20bar), that can show the title of the current view as well as display various toolbar items.
                }
                @Page(id: "addNavBarTitle", title: "", isAddable: true) {
                    Try adding `.navigationTitle("My Creatures")` as a modifier on `ContentView`. 
                    
                    This gives the view a title in the navigation bar area. You add the navigation title to each view inside your navigation view, as opposed to in the navigation view itself.
                     
                     ```
                     .navigationTitle("My Creatures")
                     ```
                }
                @Page(id: "runApp", title: "") {
                     Notice how the navigation title displays in the navigation bar at the top of your `ContentView`? These titles help a person using your app understand the content they're looking at.
                     
                    Next, you'll add a [NavigationLink](glossary://navigation%20link) to `ContentView` to navigate to the `CreatureDance` view. 
                }
            }
            @Task(type: addCode, title: "Add a `NavigationLink` to `CreatureList`", id: "addNavLinkCreatureDance", file: ContentView.swift) {
                @Page(id: "Add new link", title: "") {
                    Add a link with a destination of `CreatureDance` inside the `Section("Dance")` view. Use the label and navigation title to describe what the view does (in this case, it makes some creatures dance around!).
                }
                @Page(id: "Add new link", title: "", isHidden: true, isAddable: true) {
                    ```
                    NavigationLink("Make the Creatures Dance") { 
                        DancingCreatures()
                            .navigationTitle("Dancing Creatures")
                    }
                    ```
                }
            }
            @SuccessMessage(message: "") { 
                Congratulations, adding navigation is an essential part of creating an app. 
                
                Remember that when you use a `NavigationLink`, it only works if the view you're navigating from is inside a `NavigationStack` or a `NavigationSplitView`. 
                
                Next, you'll learn how to share data between all of your app's views.
            }
        }
        @Step(title: "Sharing Data Between Views") {
            @ContentAndMedia {  
                ![](SharingDataBetweenViews.png)

                You previously learned about how to store data [locally](glossary://local%20scope) using a [state property](glossary://state%20value), and between two views using a [binding](glossary://binding). But what if you want to share data in an app that has multiple views, like you do now? 
                
                To share the same data between multiple views, you need a single source of truth that is [separate](glossary://data%20separation) from the views. This is the [data model](glossary://data%20model), and you can share it with any views that need access to the data.
                
                A common way to construct a data model for a SwiftUI app is to use an [observable object](glossary://observable%20object). An observable object is a [type](glossary://type) with properties that multiple views can [observe](glossary://observe). Those views can watch for state changes in the properties, allowing them to update their UI to stay in sync.
            }
            @Task(type: walkthrough, title: "Your data model", id: "creatureZoo", file: CreatureZoo.swift) {
                @Page(id: "creatureZoo.observableObject", title: "") {
                    This is your data model ‚Äî the [observable object](glossary://observable%20object), `CreatureZoo`. It is a [class](glossary://class) that follows the guidelines of the `ObservableObject` [protocol](glossary://protocol). This allows the class to [publish](glossary://publish) certain properties.
                    
                    When a class publishes a property, the property broadcasts (publishes) its state changes to any [observers](glossary://observer) that might be watching. This allows [observing](glossary://observer) views to update when the state of a published property changes.
                }
                @Page(id: "creatureZoo.creatures", title: "") {
                    The [published data](glossary://published%20value) in `CreatureZoo` is the `creatures` property ‚Äî an array of `Creature` instances. Any time the data in this array changes, such as when a creature is added or removed, SwiftUI notifies all of the property [observers](glossary://observer) so they can update to show the latest data.
                }
                @Page(id: "creatureZoo.published", title: "") {
                    In an observable object, you add the `@Published` [property wrapper](glossary://property%20wrapper) to mark a property as [published](glossary://published%20value).
                }
                @Page(id: "creatureZoo.creature", title: "") {
                    To create a creature instance, use the initializer `Creature(name:emoji:)` and pass in a name, as well as a single emoji character. 
                }
                @Page(id: "creatureZoo.creatureStruct", title: "") {
                    This is the `Creature` type, which contains [properties](glossary://property) for `name`, `emoji`, `offset`, `rotation`, and `id`. 
                    
                    `Creature` follows the guidelines for the `Identifiable` [protocol](glossary://protocol) by adding an `id` property. This protocol allows SwiftUI to uniquely identify any `Creature`, even if two creatures use exactly the same emoji. This comes in handy later.
                }
            }
            @Task(type: addCode, title: "Add more creatures", id: "addCreatures", file: CreatureZoo.swift) {
                @Page(id: "addMoreData", title: "") {
                    Add at least two new `Creature` instances to the `creatures` array.
                }
                @Page(id: "addCreatures", title: "", isAddable: true) {
                    To create a new creature, [initialize](glossary://initialization) it by giving it a name and passing in a single emoji character. When adding creatures to the array, separate each creature's data with a comma; for example:
                    
                    ```
                    Creature(name: "T-Rex", emoji: "ü¶ñ"),
                    ```
                }
                @Page(id: "addOneMoreCreature", title: "", isAddable: true, isHidden: true) {
                    Add at least one more creature to your array. 
                    
                    ```
                    Creature(name: "Ladybug", emoji: "üêû"),
                    ```
                }
            }
            @Task(type: addCode, title: "Create a `StateObject`", id: "usingCreatureZoo", file: ContentView.swift) {
                @Page(id: "addStateObject", title: "") {
                    Before sharing your [observable object](glossary://observable%20object) across views, you'll first explore what it looks like to use the data model in a single view.
                    
                    In `ContentView`, initialize your observable object and create a list of creature views with the data. 

                    To initialize an observable object like `CreatureZoo`, use a special property wrapper, `@StateObject`, so that SwiftUI can manage the data.

                    ```
                    @StateObject var data = CreatureZoo()
                    ```
                }
                @Page(id: "creatureZoo.creatures", title: "") {
                    You use the `@StateObject` property wrapper to tell SwiftUI to manage the observable object for you, similar to how you use `@State` to have SwiftUI manage a property in a view as a [state property](glossary://state%20property).
                    
                    In this case, you're initializing the observable object `CreatureZoo`, and asking SwiftUI to manage it as a [state object](glossary://state%20object).
                }
            }
            @Task(type: addCode, title: "Use model data in a view", id: "createAList", file: ContentView.swift) {
                @Page(id: "listViewIntro", title: "") {
                    After initializing your data, you'll use it to create a basic view. You'll add a [ForEach](glossary://ForEach) view inside your `List` to show each of your creatures vertically in a column layout.
                }
                @Page(id: "forEach", title: "", isAddable: true) {
                    A [ForEach](glossary://ForEach) is a structure that [iterates](glossary://iteration) over a [collection](glossary://collection) of data (such as an array) to create views for each element in the collection. 

                    Add the `ForEach` below your `Section` view to iterate over your `data.creatures` array, creating a custom view to display each creature's name and emoji:
                    ```
                    /*#-code-walkthrough(forEach.id)*/
                    ForEach(data.creatures) { creature in 
                    /*#-code-walkthrough(forEach.id)*/
                        HStack { 
                            Text(creature.name)
                                .font(.title)
                            Spacer()
                            Text(creature.emoji)
                                /*#-code-walkthrough(resizableFont)*/
                                .resizableFont()
                                /*#-code-walkthrough(resizableFont)*/
                                .frame(minWidth: 125)
                        }
                    }
                    ```
                }
                @Page(id: "forEach.id", title: "") {
                    Remember how `Creature` follows the guidelines of the `Identifiable` protocol? This enables the [ForEach](glossary://ForEach) structure to uniquely identify every creature, even if they have exactly the same emoji character and name. Because it can tell apart even exact twins, this enables SwiftUI to update each view independently without mixing them up. 
                }
                @Page(id: "resizableFont", title: "") {
                    You may have noticed the `.resizableFont()` modifier used here. This is a custom modifier defined in `ResizableFont.swift` to allow your `Text` view's font size to scale up to fit the size of the view. Check out the code in that file to see how to create a custom modifier.
                }
            }
            @Task(type: addCode, title: "Make your model data accessible to the entire app", id: "addModelData", file: MyApp.swift) {
                @Page(id: "addModelDataIntro", title: "") {
                    Now that you've successfully used your observable object data in a single view, it's time to share that data with the entire app from `MyApp.swift`. 
                }
                @Page(id: "createStateObject", title: "") {
                    To make your data accessible to the entire app:
                    1. Create an instance of `CreatureZoo` as a [state object](glossary://state%20object) in `MyApp`.
                    2. Pass it into your [top-level view](glossary://top-level%20view), `NavigationStack`, as an [environment object](glossary://environment%20object).
                    
                    By passing the data to your top-level view, the environment object makes the data available to the entire [view hierarchy](glossary://view%20hierarchy) so all other views can use it.
                }
                @Page(id: "createInstanceCreatureZoo", title: "", isAddable: true) {
                    Create your instance of `CreatureZoo`, the same as you did in `CreatureList`:
                    
                    ```
                    @StateObject var data = CreatureZoo()
                    ```
                }
                @Page(id: "environmentObjectModifier", title: "", isAddable: true) {
                    Add the following modifier below the `NavigationStack`:
                    
                    ```
                    .environmentObject(data)
                    ```
                    
                    This passes your [observable object](glossary://observable%20object) instance to the app's [environment](glossary://environment), for any [subview](glossary://subview) to access.
                }
                @Page(id: "backToContentView", title: "") {
                    Next, you'll go back to `ContentView.swift` to try using the environment object.
                }
            }
            @Task(type: addCode, title: "Access an environment object", id: "useEnvironmentObject", file: ContentView.swift) {
                @Page(id: "useEnvironmentObjectIntro", title: "") {
                    Now that you've shared the observable object with all of the [subviews](glossary://subview) of your `NavigationStack`, including `ContentView`, it's time to access that data.
                }
                @Page(id: "declareEnvironmentObject", title: "", isAddable: true) {
                    Instead of using `@StateObject`, which creates a new instance of an observable object, you need to acccess the instance passed into the app [environment](glossary://environment):
                    
                    1. Delete your current `@StateObject` variable, `data`.
                    2. To access your [environment object](glossary://environment%20object), and create a new property with `@EnvironmentObject` property wrapper of type `CreatureZoo`. 
                    
                    ```
                    @EnvironmentObject var data : CreatureZoo
                    ```
                }
                @Page(id: "runTheApp", title: "", isAddable: true) {
                    Examine your list of creatures in `ContentView` preview.
                    
                    Notice that the creatures appear just as they did before. Data in the creature list is created in `MyApp`, shared through the app [environment](glossary://environment), and accessed in `ContentView`.
                }
            }
            @Task(type: experiment, title: "Replace your `HStack` with a composed `CreatureRow` view", id: "replaceHStackWithCreatureRow", file: ContentView.swift) {
                @Page(id: "improveCode", title: "") {
                    There's a great opportunity for you to improve your code here. You can simplify the code in this view by replacing the entire `HStack` inside of the [ForEach](glossary://ForEach) structure with a [composed view](glossary://composed%20view), `CreatureRow`. 
                    
                    Delete the contents of the `HStack` inside the `ForEach` and replace it with `CreatureRow(creature: creature)`.
                }
                @Page(id: "codemodularity", title: "") {
                    Take a look in `CreatureRow.swift` -- it contains the same code as you had in the `ForEach` except with a [property](glossary://property) storing a `Creature` value. 
                    
                    Now that you have `CreatureRow` as its own view, it's easier to modify and test separately from `ContentView`. Composing a view like this improves your code [modularity](glossary://modularity), a fundamental principle of creating apps.
                }
                @Page(id: "solution", title: "", isAddable: true) {
                     ```
                    ForEach(data.creatures) { creature in 
                        CreatureRow(creature: creature)
                    }
                    ```
                }
            }
            @SuccessMessage(message: "") {
                Nice!
                
                By passing an observable object into the app environment, you give access to that data to the entire [view hierarchy](glossary://view%20hierarchy). This enables any other views in your app to use the same [source of truth](glossary://source%20of%20truth), instead of trying to re-create data in multiple places.
            }
        }
        @Step(title: "Create a New View To Share Data") {
            @ContentAndMedia {  
                ![](CreateANewViewToShareData.png)

                Now that you've successfully shared data with one view, it's time to use that same data in other views. 
				
				To do this, you need to do two things:
				1. Ensure that the view accessing the data is part of the same [view hierarchy](glossary://view%20hierarchy) as the top-level view it's passed into. You add a view to the view hierarchy by initializing it within the [top-level view](glossary://top-level%20view) or any of its [subviews](glossary://subview).
				2. Access the [environment object](glossary://environment%20object).
                
                For example, if you create a new view inside `ContentView`, that new view is part of the view hierarchy since `ContentView` is a subview of your top-level view, `NavigationStack`. You can then access the environment object from that new view.
            }
            @Task(type: addCode, title: "Declare the environment object", id: "dancingCreaturesData", file: DancingCreatures.swift) {
                @Page(id: "goal", title: "") {
                    Your goal is to build a new view, `DancingCreatures`, that accesses the data in the app [environment](glossary://environment). 
                    
                    `DancingCreatures` is already part of your [view hierarchy](glossary://view%20hierarchy); you added a link to it in `ContentView`. Your next step is to access the data in the app environment.
                }
                @Page(id: "declare", title: "") {
                    To access the data in the app environment, declare your environment object for `CreatureZoo`, just like you did in `CreatureList`. It's OK to look back at your other code if you need help.
                }
                @Page(id: "varDeclaration", title: "", isHidden: true, isAddable: true) {
                    [Declare](glossary://declaration) a variable using the `@EnvironmentObject` property wrapper and give it a type of `CreatureZoo`. You don't need to [initialize](glossary://initialization) the value, because it's already initialized in `MyApp`. You only need to access the data here.
                        
                    ```
                    @EnvironmentObject var data : CreatureZoo
                    ```
                }
            }
            @Task(type: addCode, title: "Add a `DancingCreatures` view", id: "dancingCreaturesView", file: DancingCreatures.swift) {
                @Page(id: "describeTask", title: "") {
                    Now that you have access to your app data, it's time to build something fun with it. First, you'll stack all your creatures on top of each other, then, whenever you tap one, they'll scatter in different directions.
                }
                @Page(id: "addDancingCode", title: "", isAddable: true) {
                    Add this code inside your `VStack`:
                    ```
                    ZStack {
                        /*#-code-walkthrough(dance.forEach)*/
                        ForEach(data.creatures) { creature in
                        /*#-code-walkthrough(dance.forEach)*/
                            /*#-code-walkthrough(dance.textView)*/
                            Text(creature.emoji)
                                .resizableFont()
                                .offset(creature.offset)
                                .rotationEffect(creature.rotation)
                            /*#-code-walkthrough(dance.textView)*/
                            //#-learning-code-snippet(exp1)
                            //#-learning-code-snippet(animationSolution)
                            //#-learning-code-snippet(exp3)

                        }
                    }
                    /*#-code-walkthrough(dance.onTap)*/
                    .onTapGesture {
                        data.randomizeOffsets()
                    }
                    /*#-code-walkthrough(dance.onTap)*/
                    ```
                }
            }
            @Task(type: walkthrough, title: "Understanding the animation code", id: "animationWalkthrough", file: DancingCreatures.swift) {
                @Page(id: "dance.forEach", title: "") {
                    To create this animation, a [ForEach](glossary://ForEach) iterates through each of your creatures in `CreatureZoo.creatures`, creating a `Text` view for each one. 
                }
                @Page(id: "dance.textView", title: "") {
                    The `Text` view uses the creature's `offset` and `rotation` [properties](glossary://property) as arguments to the `.offset` and `.rotationEffect` modifiers. 
                    
                    Because `CreatureZoo.creatures` is a [published value](glossary://published%20value), SwiftUI updates the `DancingCreatures` view whenever a creature's `offset` or `rotation` changes.
                }
                @Page(id: "dance.onTap", title: "") {
                    The `.onTapGesture` modifier runs some code whenever you tap the view. When tapped, `data.randomizeOffsets()` changes the `offset` and `rotation` values for each creature, allowing the view to update each creature to its new location and rotation.
                }
            }
            @Task(type: addCode, title: "Animate the creatures", id: "animateCreatures", file: DancingCreatures.swift) {
                @Page(id: "animateIntro", title: "") {
                    Try tapping the view. 
                    
                    The creatures are moving, but its not very interesting looking. Next, you'll animate them to their new positions for a dancier vibe.
                }
                @Page(id: "chooseAnimation", title: "", isAddable: false) {
                    To animate the creatures to a new position, you need to tell SwiftUI which animation to use and which value to animate. In this case, you want to animate each creature's `offset` property.
                    
                    Attach the `.animation(_:value:)` modifier to the `Text` view. Choose `.default` for the animation argument, and for the value, pass in `creature.offset`. Any time the `offset` changes, the view changes are animated.
                }
                @Page(id: "animationSolution", title: "", isHidden: true, isAddable: true) {
                    ```
                    .animation(.default, value: creature.offset)
                    ```
                }
            }
            @Task(type: experiment, title: "Experiment with your view", id: "experimentWithAnimations", file: DancingCreatures.swift) {
                @Page(id: "trySomeExperiments", title: "") {
                    Now that you've gotten your creatures to animate, try tweaking the animations and other parts of the view to make it more interesting.
                }
                @Page(id: "exp1", title: "", isAddable: true) {
                    Animate changes to the `creature.rotation` property by adding a new `.animation(_:value:)` modifier.

                    Add the following modifier before the `.animation(_:value)` modifier. How does the animation change? Why do you think this is? What happens if you place the `.spring()` animation after the above modifier?

                    ```
                    .animation(.spring(response: 0.5, dampingFraction: 0.5), value: creature.rotation)
                    ```
                }
                @Page(id: "exp3", title: "", isAddable: true) {
                    Change the event handler for `.onTapGestures` to `data.synchronizeOffsets()`. This causes all of your creatures to move to the same offset. 
                    
                    1. Remove your current `.animation` modifier for `creature.offset`.
                    2. Add the following animation to make each of the animations delay a small amount.
                    
                    ```
                    .animation(.default.delay(data.indexFor(creature) / 10), value: creature.offset)
                    ```
                }
                @Page(id: "exp3", title: "") {
                    Keep tweaking your animation values until you're happy with the result!
                }
            }
            @SuccessMessage(message: "") {
                Nice work! 
                
                You've successfully created another view that uses your observable [data model](glossary://data%20model) shared with the [view hierarchy](glossary://view%20hierarchy). 
                
                Next, you'll learn how to add and delete data from that data model so people can customize the app. 
            }
        }
        @Step(title: "Add and delete creatures") {
            @ContentAndMedia {  
                ![](AddAndDeleteCreatures.png)

                 You now have a multiview app that shares a single [data model](glossary://data%20model) across multiple views. But the app doesn't feel complete yet. Even though you can add or delete a `Creature` in the code, a [user](glossary://user) can't add or delete creatures through the UI.

                 Luckily, this is very straightforward to fix. Because you have access to the data model from your views, you can make changes to the data model when a person interacts with your UI. First, you'll learn to delete a creature, then you'll create a new view that allows people to add their own creatures. 
            }
            @Task(type: addCode, title: "Delete a Creature", id: "deleteACreature", file: ContentView.swift) {
                @Page(id: "addADeleteModifier", title: "") {
                   SwiftUI makes deleting data from a `List` very straightforward. You can delete a creature by adding an `.onDelete` modifier to the `ForEach` loop in `ContentView`. 
                   
                   Adding the `.onDelete` modifier allows you to run some custom code (an `action` [closure](glossary://closure) when a person decides to delete an item). Your closure's code removes the current creature from your app's observable [data model](glossary://data%20model).
                }
                @Page(id: "addADeleteModifier", title: "", isAddable: true) {
                   Inside the `.onDelete` [closure](glossary://closure), you'll remove the current creature by calling `remove(atOffsets:)` and passing in the value `indexSet` from the closure. This finds the corresponding creature in the `creatures` array based on the row of the list you choose to delete.

                   Try adding this modifier below the `ForEach` loop and run your app. Does swiping to the left on a creature allow you to delete it?

                    ```
                    .onDelete { indexSet in 
                        data.creatures.remove(atOffsets: indexSet)
                    }
                    ```
                }
            }
            @Task(type: addCode, title: "Add a `NavigationLink` to `CreatureEditor`", id: "addToolBarContentView", file: ContentView.swift) {
                @Page(id: "goalsForAddingCreature", title: "") {
                    To add a new creature, you'll need to do two things: 
                    1. Add `CreatureEditor` to your [view hierarchy](glossary://view%20hierarchy) using a `NavigationLink`. This gives `CreatureEditor` access to your `CreatureZoo` environment object and allows a person to navigate to the view. 
                    2. [Compose](glossary://composed%20view) the `CreatureEditor` view to allow a person to edit and add a new creature to the `creatures` array in `CreatureZoo`. 
                }
                @Page(id: "addingANavigationLink", title: "") {
                    Start by deciding where to add a `NavigationLink` to `CreatureEditor`. Because you already have a `List` view of creatures that you can delete from in `ContentView`, it makes sense to add a creature from the same view.
                }
                @Page(id: "hint1", title: "") {
                    To make creature editing easily accessible, place a link in the [navigation bar](glossary://navigation%20bar) in the `ContentView` UI. This is the perfect place for this type of link, because it's in a familiar place where people look for additional features of your app.
                }
                @Page(id: "hint2", title: "", isAddable: false) {
                    To add a button to the navigation bar: 
                    1. Add navigation bar customization by attaching the `.toolbar` modifier to your `List` view. 
                    2. Inside the `.toolbar` closure, add a `ToolbarItem`. This is an item that you can place in the toolbar. 
                    3. Add a `NavigationLink` to `CreatureEditor` inside the `ToolbarItem`. This is the view you'll see in the navigation bar.

                    ```
                    .toolbar { 
                        ToolbarItem { 
                            // Add NavigationLink to CreatureEditor

                        }
                    }
                    ```
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: true) {
                    ```
                    .toolbar { 
                        ToolbarItem { 
                            NavigationLink("Add") { 
                                CreatureEditor()
                            }
                        }
                    }
                    ```
                }
            }
            @Task(type: addCode, title: "Add a navigation title to `CreatureEditor`", id: "addNavigationTitleCreatureEditor", file: ContentView.swift) {
                @Page(id: "addNavigationTitleCreatureEditor", title: "") {
                    Next, give `CreatureEditor` a navigation title that describes the view's purpose.
                    
                    1. Add a navigation title to the `CreatureEditor` view.  
                    2. Run your app and test navigating to `CreatureEditor` from `ContentView`.
                }
                @Page(id: "addNavigationTitleCreatureEditor", title: "", isHidden: true, isAddable: false) {
                    
                    ```
                    .toolbar { 
                        ToolbarItem { 
                            NavigationLink("Add") { 
                                CreatureEditor()
                                    .navigationTitle("Add Creature")
                            }
                        }
                    }
                    ```
                }
            }
            @Task(type: addCode, title: "Define the `CreatureEditor` data", id: "defineVariablesCreatureEditor", file: CreatureEditor.swift) {
                @Page(id: "addingACreature", title: "") {
                    To add a new creature, you'll create a [composed view](glossary://composed%20view) `CreatureEditor` that allows you to edit a new creature and add it to your [data model](glossary://data%20model). 
                }
                @Page(id: "addingACreature", title: "") {
                    Take a moment to think through which [properties](glossary://property) you'll need in `CreatureEditor` to create a new `Creature` instance and add it to your data model.
                    1. You'll need a `Creature` property that you can modify within the [local](glossary://local%20scope) `CreatureEditor` view. 
                    2. You'll need access to your `CreatureZoo` [observable object](glossary://observable%20object) from the [environment](glossary://environment) so you can add your `Creature` instance to it. 

                    Try creating two properties that accomplish these goals, using the following hints if you get stuck.
                }
                @Page(id: "hint1", title: "", isHidden: true) {
                    First, create a [state property](glossary://state%20property) that stores a `Creature` instance. You can leave its `name` and `emoji` parameters as empty strings for now.
                }
                @Page(id: "hint2", title: "", isHidden: true) {
                    Next, declare an [environment object](glossary://environment%20object) of type `CreatureZoo` to access your [observable object](glossary://observable%20object) instance. 
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: true) {
                    ```
                    @State var newCreature : Creature = Creature(name: "", emoji: "")
                    @EnvironmentObject var data : CreatureZoo 
                    ```
                }
            }
            @Task(type: addCode, title: "Create a Form in CreatureEditor", id: "defineYourView", file: CreatureEditor.swift) {
                @Page(id: "newView", title: "", isAddable: true) {
                    To build the `CreatureEditor` view, you can use a built-in `Form` view, which is great when handling data entry. 
                    
                    Inside of the `Form`, you'll add three `Section` views: One each for editing the creature's name, emoji, and a preview.

                    ```
                    Form {
                        Section("Name") {
                            //#-learning-code-snippet(addACreatureEditorTextField)

                        }   
            
                        Section("Emoji") {
                            
                        }
            
                        Section("Creature Preview") {
                            CreatureRow(creature: newCreature)
                        }
                    }
                    ``` 
                }
            }
            @Task(type: addCode, title: "Add `TextField` views for user input", id: "addACreatureEditorTextField", file: CreatureEditor.swift) {
                @Page(id: "textFieldIntro", title: "") {
                    Next, you need to add a way for [people](glossary://user) to edit the `name` and `emoji` values for the `Creature` [state property](glossary://state%20property). 
                    
                    You do this by adding a [TextField](doc://com.apple.documentation/documentation/swiftui/textfield) view, which allows people to enter some text. 

                    Add two `TextField` views to edit the creature `name` and `emoji` values. 
                    Use the `TextField(_:text:)` initializer, which takes arguments for a [label](glossary://label) and a [binding](glossary://binding) `String` value. 
                }
                @Page(id: "bindingValue", title: "", isAddable: false) {
                    Remember, a binding requires that the source of truth is managed by SwiftUI, such by a [state property](glossary://state%20property). 

                    Pass in a binding to your `Creature` state property, and specify the `name` and `emoji` values like this:
                    
                    ```
                    $newCreature.name
                    $newCreature.emoji
                    ```
                }
                @Page(id: "addTextField", title: "", isHidden: true, isAddable: true) {
                    Here's an example of how to add a `TextField`. Add one `TextField` for editing `newCreature.name` and another for editing `newCreature.emoji`.
                    ```
                    TextField("Name", text: $newCreature.name)
                    ```
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: false) {
                    ```
                    Form {
                        Section("Name") {
                            TextField("Name", text: $newCreature.name)
                        }   
            
                        Section("Emoji") {
                            TextField("Emoji", text: $newCreature.emoji)
                        }
            
                        Section("Creature Preview") {
                            CreatureRow(creature: newCreature)
                        }
                    }
                    ``` 
                }
            }
            @Task(type: addCode, title: "Place an add button in the toolbar", id: "addButtonToToolbar", file: CreatureEditor.swift) {
                @Page(id: "addToolBar", title: "") {
                    Next, you need to add a `Button` that people can tap to add their new creature. 
                    
                    Just like in `ContentView`, the best place to put a button like this is in the [navigation bar](glossary://navigation%20bar) of `CreatureEditor`. 
                }
                @Page(id: "addToolBarItem", title: "", isAddable: true) {
                    Try using the `.toolbar` code from `ContentView` as an example to add a toolbar to `CreatureEditor`:
                    
                    1. Add the `.toolbar` modifier below your `VStack`. 
                    2. Inside the toolbar, add a `ToolbarItem`. 
                    3. Inside the `ToolbarItem`, add a `Button` with a [label](glossary://label) that reads "Add". You can leave the action [closure](glossary://closure) for the `Button` empty for now.
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: true) {
                    ```
                    .toolbar { 
                        ToolbarItem { 
                            Button("Add") { 
                                //#-learning-code-snippet(addCreatureToCreatureZoo)
                                //#-learning-code-snippet(dismissCall)
                            }
                        }
                    }
                    ```
                }
            }
            @Task(type: addCode, title: "Add your creature to `CreatureZoo`", id: "addCreatureToCreatureZoo", file: CreatureEditor.swift) {
                @Page(id: "addButtonGoal", title: "") {
                    When you tap the Add button, you want to add your creature instance to your observable object, `CreatureZoo`. Specifically, you want to append the creature to the `creatures` array. 
                }
                @Page(id: "appendCreature", title: "", isAddable: true) {
                    The following code adds the creature being edited to `data.creatures`. Remember, `creatures` is a [published value](glossary://published%20value), so any changes to that value causes all of the views that use that data to automatically update. 

                    Add this code inside the action [closure](glossary://closure) for your `Button`.
                    
                    ```
                    data.creatures.append(newCreature)
                    ```
                }
                @Page(id: "tryRunning", title: "") {
                    Run your app and try adding a new creature. 
                    
                    Navigate back to `ContentView` to see if the new creature was added to the `List` view. Was it also added in the `DancingCreatures` view? 
                }
            }
            @Task(type: experiment, title: "Dismiss the editor when you tap Add", id: "dismissEditor", file: CreatureEditor.swift) {
                @Page(id: "dismissCreatureEditor", title: "") {
                    After you add a creature, your `CreatureEditor` view dismisses, showing the previous view you navigated from. This is a better user experience, and it prevents you from tapping the Add button more than once, which would just add the same creature again and again. 
                }
                @Page(id: "environmentValue", title: "", isAddable: true) {
                    To dismiss the view, you need two things: 
                    1. Declare the [environment](glossary://environment) value `dismiss`, which allows the app to dismiss the current view being presented in the `NavigationStack`. 
                    2. [Call](glossary://call) `dismiss()` when tapping the Add button.

                    ```
                    @Environment(\.dismiss) var dismiss
                    ```
                }
                @Page(id: "dismissCall", title: "", isAddable: true) {
                    After you've declared the [environment](glossary://environment) value `dismiss`, call `dismiss()` when you tap Add, after you've added your new creature to `data.creatures`. 

                    ```
                    dismiss()
                    ```
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: false) {
                    ```
                    .toolbar { 
                        ToolbarItem { 
                            Button("Add") { 
                                data.creatures.append(newCreature)
                                dismiss()
                            }
                        }
                    }
                    ```
                }
            }
            @SuccessMessage(message: "") {
                Congratulations, you've created a fully functioning app! 
                
                You have the ability to add new creatures, view and edit them in `CreatureList`, and watch them dance in `DancingCreatures`. 
            }
        }
        @Step(title: "Add a `CreatureDetail` view") {
            @ContentAndMedia { 
                ![](AddCreatureDetailView.png)
                
                Now that you know how to navigate between views, manage [local](glossary://local%20scope) state changes, share data across your whole app, and use a variety of [built-in SwiftUI views](glossary://built-in%20view), it's time to put your skills to the test to create a new view: `CreatureDetail`, a view shows the details for a single creature in your list.

                Your list of creatures is nice to look at, but needs a bit more interactivity. What good is having all these creatures if you can't tinker with them? 
            }
            @Task(type: addCode, title: "Add a `NavigationLink` to `CreatureDetail`", id: "addNavigationLinkCreatureDetail", file: ContentView.swift) {
                @Page(id: "forEachNavLink", title: "") {
                    Your goal is to make every view of your [ForEach](glossary://ForEach) loop into its own `NavigationLink`, each of which navigates to a detail view of a creature in your `data.creatures` array.
                }
                @Page(id: "replaceForEachContentsWithNavLink", title: "") {
                    To do this, replace the current contents of the `ForEach` loop with a `NavigationLink`:
                    
                    1. Set the [destination](glossary://destination%20view) to be the [composed view](glossary://composed%20view) `CreatureDetail(creature: creature)`. 
                    2. Create the [label](glossary://label) as a `CreatureRow`, using the `creature` value from the [closure](glossary://closure) as the [argument](glossary://argument).
                }
                @Page(id: "navLinkToCreatureDetail", title: "", isHidden: true) {
                    Create your navigation link like this and add it inside your `ForEach`:
                    
                    ```
                    NavigationLink {
                        CreatureDetail(creature: creature)
                            .navigationTitle(creature.name)
                    } label: {
                        CreatureRow(creature: creature)
                    }
                    ```
                }
                @Page(id: "solution", title: "", isHidden: true, isAddable: false) {
                    Your `ForEach` should look like this:
                    ```
                    ForEach(data.creatures) { creature in 
                        NavigationLink {
                            CreatureDetail(creature: creature)
                                .navigationTitle(creature.name)
                        } label: {
                            CreatureRow(creature: creature)
                        }  
                    }
                    ```
                }  
                @Page(id: "tapTheLinks", title: "") {
                    Try tapping a row of your `List`. It now takes you to the `CreatureDetail` view for that creature.
                }
            }
            @Task(type: walkthrough, title: "Build your `CreatureDetail` view", id: "creatureDetailWalkthrough", file: CreatureDetail.swift) {
                @Page(id: "creatureDetail.intro", title: "") {
                    The `CreatureDetail` view shows the selected creature as a `Text` view. Your job is to understand the existing code and build on top of it to create some cool creature effects.
                }
                @Page(id: "creatureDetail.creatureConstant", title: "") {
                    In `ContentView`, you created a `NavigationLink` with a [destination view](glossary://destination%20view) of `CreatureDetail(creature: creature)`.
                    
                    The destination view uses the `Creature` value for each row of the list to generate a different view depending on which creature you tap. Here, that value is stored as a nonstate [constant](glossary://constant) because the value won't change in this view.
                }
                @Page(id: "creatureDetail.stateVars", title: "") {
                    Three [state properties](glossary://state%20property) have been defined for you:
                    1. `color` tracks a `Color` value, and controls color modifications to your `Text` view. 
                    2. `shadowRadius` is a `Double` value that you use to control the radius of a `.shadow` modifier. 
                    3. `angle` is an `Angle` value that you use to rotate your `Text` view.
                }
                @Page(id: "creatureDetail.textView", title: "") {
                    Your `Text` view uses `creature.emoji` as the String value for the view, and adds several modifiers that determine the view's appearance and behavior:
                    
                    1. [.colorMultiply](doc://com.apple.documentation/documentation/swiftui/list/colormultiply(_:)) adds a color multiplication effect to the view.
                    2. [.shadow](doc://com.apple.documentation/documentation/swiftui/list/shadow(color:radius:x:y:)) adds a shadow of a particular color and radius.
                    3.  [.rotation3DEffect](doc://com.apple.documentation/documentation/swiftui/view/rotation3deffect(_:axis:anchor:anchorz:perspective:)) can control the rotation of the view in three dimensions. 
                }
            }
            @Task(type: addCode, title: "Add a `ColorPicker` that changes the `color` value", id: "addColorPicker", file: CreatureDetail.swift) {
                @Page(id: "addColorPicker", title: "") {
                    To start building some interaction into this view, first add a `ColorPicker` view below the `Text` view. This changes the state property `color` when a new color is chosen.

                    Try to do this yourself, using the solution if you get stuck. 
                }
                @Page(id: "addColorPicker", title: "", isHidden: true, isAddable: true) {
                    ```
                    ColorPicker("Choose a Color", selection: $color)
                    ```
                }
            }
            @Task(type: addCode, title: "Add a `Slider` that controls the shadow radius", id: "addSliderShadowRadius", file: CreatureDetail.swift) {
                @Page(id: "addColorPicker", title: "") {
                    Below the `ColorPicker` add a `Slider` that controls the `shadowRadius` value.

                    Try to do this yourself, using the solution if you get stuck. 
                }
                @Page(id: "addColorPicker", title: "", isHidden: true, isAddable: true) {
                    ```
                    HStack { 
                        Text("Shadow")
                        Slider(value: $shadowRadius)
                    }
                    ```
                }
            }
            @Task(type: addCode, title: "Add a `Button` that changes the size of the creature", id: "addScaleButton", file: CreatureDetail.swift) {
                @Page(id: "addScalingButton", title: "") {
                    Below the `Slider`, add a `Button` that people can use to scale the `Text` view up and down: 

                    1. Create a new [state property](glossary://state%20property) that tracks a `Boolean` value, just like you did in `ConditionalCircle`. 
                    2. Add a new modifier, [.scaleEffect](doc://com.apple.documentation/documentation/swiftui/view/scaleeffect(_:anchor:)-pmi7) along with a [ternary conditional operator](glossary://ternary%20conditional%20operator) to determine the scale when the Boolean is `true` versus when its `false`.
                    3. Change your `Button` action [closure](glossary://closure) to toggle the Boolean value between `true` and `false` states.
                }
                @Page(id: "tryOnYourOwn", title: "") {
                    Try completing this task by looking back at the code in `ConditionalCircle`. If you need help, look at the following hints:
                }
                @Page(id: "addStateVarIsScaled", title: "", isHidden: true, isAddable: true) {
                    Create a [state property](glossary://state%20property) outside of the view [body](glossary://body) that tracks a Boolean value.

                    ```
                    @State var isScaled = false
                    ```
                }
                @Page(id: "addScaleEffectModifier", title: "", isHidden: true, isAddable: true) {
                    Add the `.scaleEffect` modifier to the `Text` view that controls the scale using a [ternary conditional operator](glossary://ternary%20conditional%20operator).

                    ```
                    .scaleEffect(isScaled ? 1.5 : 1)
                    ```
                }
                @Page(id: "addButton", title: "", isHidden: true, isAddable: true) {
                    Add the `Button` and set its action to call `isScaled.toggle()`.

                    ```
                    Button("Scale") { 
                        isScaled.toggle()
                    }
                    ```
                }
            }
            @Task(type: addCode, title: "Animate your changes to `isScaled`", id: "animateChangesIsScaled", file: CreatureDetail.swift) {
                @Page(id: "animateChanges", title: "") {
                    This scale effect falls a little flat; wouldn't it be better if it were animated? 

                    Use the `.animation(_:value:)` modifier to animate any changes to the `isScaled` variable. Try using the `.spring(response:dampingFraction:blendDuration:)` animation, and passing in a value of `0.5` for each parameter.
                }
                @Page(id: "animationSolution", title: "", isHidden: true, isAddable: true) {
                    ```
                    .animation(.spring(response: 0.5, dampingFraction: 0.5, blendDuration: 0.5), value: isScaled)
                    ```
                }
            }
            @Task(type: experiment, title: "Use `isScaled` to Rotate Your View", id: "useIsScaledRotateView", file: CreatureDetail.swift) {
                @Page(id: "rotateTheTextView", title: "") {
                    To add a final little flair, create a conditional value in the `.rotation3DEffect` modifier's `angle` parameter, then set it to `Angle(degrees: 0)` if `isScaled` is `true`, or `Angle(degrees: 360)` if `false`.

                    You'll use the [ternary conditional operator](glossary://ternary%20conditional%20operator) to do this. 
                }
                @Page(id: "rotationSolution", title: "", isHidden: true, isAddable: true) {
                    ```
                    .rotation3DEffect(isScaled ? Angle(degrees: 0) : Angle(degrees: 360), axis: (x: 5, y: 2, z: 1))
                    ```
                }
            }
            @Task(type: experiment, title: "Customize your `CreatureDetail` view", id: "customizeCreature", file: CreatureDetail.swift) {
                @Page(id: "rotateTheTextView", title: "") {
                    Now that you've got the hang of customizing views with [user interaction](glossary://user%20interaction), try adding one more [built-in view](glossary://built-in%20view) so people can modify the `Text` view.

                    You could use a `Slider` to change the view's width, height, blur, contrast, or saturation, a `Button` to enable a `RotationEffect`, or some other effect that you think of. Try tinkering around to see what effects you can create. 
                }
            }
            @SuccessMessage(message: "") {
                Excellent Work! 
                
                You've created a full-fledged app that allows you to view, add, delete, dance with, and modify creatures. Pat yourself on the back, because this was no small feat. 

                You've successfully completed this tutorial, but you've only just begun your journey in building apps. The more you apply the concepts you've learned, the better you'll remember them ‚Äî and the more apps you'll be able to create. In the next experiments, try using everything you've learned in this tutorial to write some of your own examples. Good luck!
            }
        }
        @Step(title: "Create on Your Own") {
            @ContentAndMedia { 
                ![](CreateYourOwnCopy.png)
                
                Now that you've completed your journey learning about state and data flow, it's time for you to unlease your creativity to create a new view that uses your creature data. 

                When you're done with the experiments here, try creating your own project from scratch using the same concepts you've learned in this tutorial. 
            }
            @Task(type: experiment, title: "Create your Own View", id: "createYourOwn", file: ContentView.swift) {
                @Page(id: "newView", title: "") {
                    Things to try: 
                    
                    - Create a new view that uses your `creatures` array and link to it as a destination in `ContentView`.
                    - Add a new [published value](glossary://published%20value) to `CreatureZoo` and use it in one or more of your existing views.
                    - Give each creature a `description` property, and create a new view that displays their descriptions, names, and images in a fun layout.
                }
            }
            @Task(type: experiment, title: "Create your own app", id: "createNewApp", file: ContentView.swift) {
                @Page(id: "newApp", title: "") {
                    Think of and create an entirely new project using SwiftUI. Implement your own `NavigationStack` to move between views, use [state properties](glossary://state%20property) to change the appearance of views locally, built-in SwiftUI views and [bindings](glossary://binding) to enable user interactions, and an [observable object](glossary://observable%20object) passed into the app environment to share data across multiple views. If you get stuck, come back to this project and look at code examples to fix any bugs you run into. Good luck, you can do this!
                }
            }
        }
    }
}
